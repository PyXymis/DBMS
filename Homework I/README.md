# Homework I
Приветствую, уважаемые проверяющие данную работу. Выбор темы я сочетаю со своей работой - Food-Tech, и в около похожем виде для составления схемы первой базы данных собрал таблицы базовой бизнес логики продукта, включая тавтологию полей и запутанность связей. В общем-то, цель: “сделать грязную схему” -  не выполнена. Слишком мало таблиц и связей я перенес, чтобы получить структуру похожую на нашу

    Схема таблицы: https://dbdesign.online/model/LDCflu9OcAdd

# Документация

На представленной схеме отражено 13 таблиц, даю краткое описание по каждой 
из них:

1. city - таблица для хранения города и привязки его к таблице address;
2. address - таблица для хранения адреса, включающая все возможные величины адреса, наличия домофона и пожелания клиента по его использованию, а также в поле -geolocation полный ответ ( json ) от общедоступного сервиса геолокации;
3. loyalty_card - таблица для хранения карт лояльности пользователей с полем отражающем балльный баланс пользователя;
4. pay_card - таблица для хранения банковских карт пользователя;
5. push_token - таблица для хранения push токенов, которые приложение запрашивает у сервиса push рассылок;
6. account - таблица для хранения информации о пользователе, также используется для superuser/admin сайта, поэтому большинство полей могут быть null, так как не заполняются у staff;
7. cart - таблица для хранения информации о корзине пользователя;
8. cart_item -  таблица для хранения информации о продуктах, которые находятся в корзине у пользователя, в том числе подарки и бесплатные сопутки ( палочки для роллов / пластиковые приборы );
9. order - таблица для хранения информации о заказе, его статус, предзаказ ко времени или send_sooner, address и account, а также использование промокодов. Основная таблица в бизнес-логике;
10. order_status - таблица для хранения информации о статусах заказов, в т.ч. поле соответствия для отображения клиенту в приложение. 
11. order_item - таблица для хранения товаров с учетом их скидок и цены на момент оформления заказа, необходима для отображения клиентам корректной истории заказов
12. catalog - таблица для хранения информации о категориях блюд, включает поля parent_id ссылающегося на самого себя и level для отображения структуры вложенного списка 
13. product - таблица для хранения информации о товарах, их цена и цена с учетом временной скидки, время публикации, кол-во на складе, ссылки на картинки

# Примеры бизнес-задач
- Просто оформить заказ: Клиент наполняет корзину товарами, переводит cart_items в order_items, формирует заказ и оплачивает его. Заказ переходит в цех и становится доступным в приложение курьера
- Push рассылка специального промокода: Маркетинг заводит промокод, составляет сообщение для рассылки, использует сервис рассылки и отправляет клиентам промокод. Клиенту получают его и по активации в их корзине появляется товар с флагом is_present, получение которого возможно при оформление доставки
- Активация категории используя поля publish_from / publish_to на приуроченный праздник, к примеру, создание позиций товаров с блинами и активация категории в период масленицы

# Рекомендации по репликации БД
Так как приложение с сфере food-tech будет испытывать высокую нагрузку по RPS - мы будем использовать множество подов(k8s) для обработки запросов. При такой нагрузке реплицируя БД опасно поднимать второго и более мастеров, т.к. есть множество невзаимодействующих друг с другом экземпляров сервера. Следовательно, вариант Master-master мы откидываем. Соответственно, мы склоняемся к варианту master-slave или для большей производительности - slave-slave

Далее, выбирая между логической и физической репликации мы должны учесть особенности реализаций. Логическая репликация может быть полезна, когда реплики (slave) содержат лишь часть структуры данных базы, куда мы пишем (master), что на больших объемах полей данных может сыграть весомую роль.
В примере текущей структуры я предполагаю физическую репликацию, т.е. 

полное копирование данных и структур Master в Slaves и распределение slave по серверам для повышения доступности приложения

# Рекомендации по резервному копированию 
В нашем арсенале есть несколько способов резервного копирования БД:
Полное, инкрементное, дифференциальное и, иногда выделяют, онлайн-резервное хранение

Я не смогу придумать схему лучше, чем нам предлагает Yandex Cloud. Используя ее в работе и опираясь на нее в дни кризиса я осознал ее ценность, поэтому, рекомендацию дам согласно своему пониманию механизма резервного копирования в Яндексе

Раз в 2-3 дня мы будем делать полное копирование Базы данных. Раз в день сохраняем дифференциальное. А каждый час создаем инкрементные резервные копии

В итоге по прошествию недели работы мы будем иметь:
- 2-3 полных физических верных копии БД;
- 6-7 дифференциальных копий БД;
- ~160 инкрементных копий БД;
  
Имея такой запас данных мы сможем прийти максимально быстро к любому необходимому состоянию БД как на продовом окружение, так и на тестовых
